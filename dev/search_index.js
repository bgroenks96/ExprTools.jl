var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = ExprTools","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"splitdef\ncombinedef\nsignature","category":"page"},{"location":"api/#ExprTools.splitdef","page":"API","title":"ExprTools.splitdef","text":"splitdef(ex::Expr; throw::Bool=true) -> Union{Dict{Symbol,Any}, Nothing}\n\nSplit a function definition expression into its various components including:\n\n:head: Expression head of the function definition (:function, :(=), :(->))\n:name: Name of the function (not present for anonymous functions)\n:params: Parametric types defined on constructors\n:args: Positional arguments of the function\n:kwargs: Keyword arguments of the function\n:rtype: Return type of the function\n:whereparams: Where parameters\n:body: Function body (not present for empty functions)\n\nAll components listed may not be present in the returned dictionary with the exception of :head which will always be present.\n\nIf the provided expression is not a function then an exception will be raised when throw=true. Use throw=false avoid raising an exception and return nothing instead.\n\nSee also: combinedef\n\n\n\n\n\n","category":"function"},{"location":"api/#ExprTools.combinedef","page":"API","title":"ExprTools.combinedef","text":"combinedef(def::Dict{Symbol,Any}) -> Expr\n\nCreate a function definition expression from various components. Typically used to construct a function using the result of splitdef.\n\nIf def[:head] is not provided it will default to :function.\n\nFor more details see the documentation on splitdef.\n\n\n\n\n\n","category":"function"},{"location":"api/#ExprTools.signature","page":"API","title":"ExprTools.signature","text":"signature(m::Method) -> Dict{Symbol,Any}\n\nFinds the expression for a method's signature as broken up into its various components including:\n\n:name: Name of the function\n:params: Parametric types defined on constructors\n:args: Positional arguments of the function\n:whereparams: Where parameters\n\nAll components listed above may not be present in the returned dictionary if they are not in the function definition.\n\nLimited support for:\n\n:kwargs: Keyword arguments of the function. Only the names will be included, not the default values or type constraints.\n\nUnsupported:\n\n:rtype: Return type of the function\n:body: Function body0\n:head: Expression head of the function definition (:function, :(=), :(->))\n\nFor more complete coverage, consider using splitdef with CodeTracking.definition.\n\nThe dictionary of components returned by signature match those returned by splitdef and include all that are required by combinedef, except for the :body component.\n\n\n\n\n\n","category":"function"},{"location":"#ExprTools","page":"Home","title":"ExprTools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExprTools provides tooling for working with Julia expressions during metaprogramming. This package aims to provide light-weight performant tooling without requiring additional package dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively see the MacroTools package for more powerful set of tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ExprTools provides tooling for working with Julia expressions during metaprogramming. This package aims to provide light-weight performant tooling without requiring additional package dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively see the MacroTools package for more powerful set of tools.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, this package provides the splitdef, signature and combinedef functions which are useful for inspecting and manipulating function definition expressions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"splitdef works on a function definition expression and returns a Dict of its parts.\ncombinedef takes Dict from splitdef and builds it into an expression.\nsignature works on a Method returning a similar Dict that holds the parts of the expressions that would form its signature.","category":"page"},{"location":"","page":"Home","title":"Home","text":"e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ExprTools\n\njulia> ex = :(\n           function Base.f(x::T, y::T) where T\n               x + y\n           end\n       )\n:(function Base.f(x::T, y::T) where T\n      #= none:3 =#\n      x + y\n  end)\n\njulia> def = splitdef(ex)\nDict{Symbol,Any} with 5 entries:\n  :args        => Any[:(x::T), :(y::T)]\n  :body        => quoteâ€¦\n  :name        => :(Base.f)\n  :head        => :function\n  :whereparams => Any[:T]\n\njulia> def[:name] = :g;\n\njulia> def[:head] = :(=);\n\njulia> def[:body] = :(x * y);\n\njulia> g_expr = combinedef(def)\n:((g(x::T, y::T) where T) = x * y)\n\njulia> eval(g_expr)\ng (generic function with 1 method)\n\njulia> g_method = first(methods(g))\ng(x::T, y::T) where T in Main\n\njulia> signature(g_method)\nDict{Symbol,Any} with 3 entries:\n  :name        => :g\n  :args        => Expr[:(x::T), :(y::T)]\n  :whereparams => Any[:T]","category":"page"}]
}
